From e0d8e79c6e8a015b274a8dade8db620c4cb19d87 Mon Sep 17 00:00:00 2001
From: caiyinyu <caiyinyu@loongson.cn>
Date: Tue, 27 Jul 2021 15:29:12 +0800
Subject: [PATCH 06/55] LoongArch: ABI Implementation

This is meant to contain all the LoongArch code that needs to explicitly
name registers or manage in-memory structure layout.  This does not
contain any of the Linux-specific code.

        * sysdeps/loongarch/__longjmp.S: New file.
        * sysdeps/loongarch/bits/endianness.h: Likewise.
        * sysdeps/loongarch/bits/link.h: Likewise.
        * sysdeps/loongarch/bits/setjmp.h: Likewise.
        * sysdeps/loongarch/bits/wordsize.h: Likewise.
        * sysdeps/loongarch/dl-machine.h: Likewise.
        * sysdeps/loongarch/dl-trampoline.S: Likewise.
        * sysdeps/loongarch/gccframe.h: Likewise.
        * sysdeps/loongarch/jmpbuf-offsets.h: Likewise.
        * sysdeps/loongarch/jmpbuf-unwind.h: Likewise.
        * sysdeps/loongarch/ldsodefs.h: Likewise.
        * sysdeps/loongarch/linkmap.h: Likewise.
        * sysdeps/loongarch/machine-gmon.h: Likewise.
        * sysdeps/loongarch/memusage.h: Likewise.
        * sysdeps/loongarch/setjmp.S: Likewise.
        * sysdeps/loongarch/sotruss-lib.c: Likewise.
        * sysdeps/loongarch/start.S: Likewise.
        * sysdeps/loongarch/sys/asm.h: Likewise.
        * sysdeps/loongarch/tls-macros.h: Likewise.
        * sysdeps/loongarch/tst-audit.h: Likewise.
        * sysdeps/unix/sysv/linux/loongarch/localplt.data: Likewise.
        * sysdeps/unix/sysv/linux/loongarch/lp64/jmp_buf-macros.h:
          Likewise.
---
 sysdeps/loongarch/__longjmp.S                 |  50 +++
 sysdeps/loongarch/bits/endianness.h           |  11 +
 sysdeps/loongarch/bits/link.h                 |  58 +++
 sysdeps/loongarch/bits/setjmp.h               |  39 ++
 sysdeps/loongarch/bits/wordsize.h             |  25 ++
 sysdeps/loongarch/dl-machine.h                | 365 ++++++++++++++++++
 sysdeps/loongarch/dl-trampoline.S             | 108 ++++++
 sysdeps/loongarch/gccframe.h                  |  21 +
 sysdeps/loongarch/jmpbuf-offsets.h            |  22 ++
 sysdeps/loongarch/jmpbuf-unwind.h             |  44 +++
 sysdeps/loongarch/ldsodefs.h                  |  46 +++
 sysdeps/loongarch/linkmap.h                   |   4 +
 sysdeps/loongarch/machine-gmon.h              |  37 ++
 sysdeps/loongarch/memusage.h                  |  25 ++
 sysdeps/loongarch/setjmp.S                    |  53 +++
 sysdeps/loongarch/sotruss-lib.c               |  50 +++
 sysdeps/loongarch/start.S                     |  71 ++++
 sysdeps/loongarch/sys/asm.h                   |  67 ++++
 sysdeps/loongarch/tls-macros.h                |  49 +++
 sysdeps/loongarch/tst-audit.h                 |  23 ++
 .../unix/sysv/linux/loongarch/localplt.data   |  19 +
 .../linux/loongarch/lp64/jmp_buf-macros.h     |  43 +++
 22 files changed, 1230 insertions(+)
 create mode 100644 sysdeps/loongarch/__longjmp.S
 create mode 100644 sysdeps/loongarch/bits/endianness.h
 create mode 100644 sysdeps/loongarch/bits/link.h
 create mode 100644 sysdeps/loongarch/bits/setjmp.h
 create mode 100644 sysdeps/loongarch/bits/wordsize.h
 create mode 100644 sysdeps/loongarch/dl-machine.h
 create mode 100644 sysdeps/loongarch/dl-trampoline.S
 create mode 100644 sysdeps/loongarch/gccframe.h
 create mode 100644 sysdeps/loongarch/jmpbuf-offsets.h
 create mode 100644 sysdeps/loongarch/jmpbuf-unwind.h
 create mode 100644 sysdeps/loongarch/ldsodefs.h
 create mode 100644 sysdeps/loongarch/linkmap.h
 create mode 100644 sysdeps/loongarch/machine-gmon.h
 create mode 100644 sysdeps/loongarch/memusage.h
 create mode 100644 sysdeps/loongarch/setjmp.S
 create mode 100644 sysdeps/loongarch/sotruss-lib.c
 create mode 100644 sysdeps/loongarch/start.S
 create mode 100644 sysdeps/loongarch/sys/asm.h
 create mode 100644 sysdeps/loongarch/tls-macros.h
 create mode 100644 sysdeps/loongarch/tst-audit.h
 create mode 100644 sysdeps/unix/sysv/linux/loongarch/localplt.data
 create mode 100644 sysdeps/unix/sysv/linux/loongarch/lp64/jmp_buf-macros.h

diff --git a/sysdeps/loongarch/__longjmp.S b/sysdeps/loongarch/__longjmp.S
new file mode 100644
index 0000000000..18b5ef67a5
--- /dev/null
+++ b/sysdeps/loongarch/__longjmp.S
@@ -0,0 +1,50 @@
+/* longjmp, LoongArch version.
+   Copyright (C) 2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include <sys/asm.h>
+
+ENTRY (__longjmp)
+  REG_L ra, a0, 0*SZREG
+  REG_L sp, a0, 1*SZREG
+  REG_L x,  a0, 2*SZREG
+  REG_L fp, a0, 3*SZREG
+  REG_L s0, a0, 4*SZREG
+  REG_L s1, a0, 5*SZREG
+  REG_L s2, a0, 6*SZREG
+  REG_L s3, a0, 7*SZREG
+  REG_L s4, a0, 8*SZREG
+  REG_L s5, a0, 9*SZREG
+  REG_L s6, a0, 10*SZREG
+  REG_L s7, a0, 11*SZREG
+  REG_L s8, a0, 12*SZREG
+
+  FREG_L $f24, a0, 13*SZREG + 0*SZFREG
+  FREG_L $f25, a0, 13*SZREG + 1*SZFREG
+  FREG_L $f26, a0, 13*SZREG + 2*SZFREG
+  FREG_L $f27, a0, 13*SZREG + 3*SZFREG
+  FREG_L $f28, a0, 13*SZREG + 4*SZFREG
+  FREG_L $f29, a0, 13*SZREG + 5*SZFREG
+  FREG_L $f30, a0, 13*SZREG + 6*SZFREG
+  FREG_L $f31, a0, 13*SZREG + 7*SZFREG
+
+  sltui a0,a1,1
+  add.d a0, a0, a1   # a0 = (a1 == 0) ? 1 : a1
+  jirl  zero,ra,0
+
+END (__longjmp)
diff --git a/sysdeps/loongarch/bits/endianness.h b/sysdeps/loongarch/bits/endianness.h
new file mode 100644
index 0000000000..7290be7b18
--- /dev/null
+++ b/sysdeps/loongarch/bits/endianness.h
@@ -0,0 +1,11 @@
+#ifndef _BITS_ENDIANNESS_H
+#define _BITS_ENDIANNESS_H 1
+
+#ifndef _BITS_ENDIAN_H
+#error "Never use <bits/endianness.h> directly; include <endian.h> instead."
+#endif
+
+/* LoongArch is little-endian.  */
+#define __BYTE_ORDER __LITTLE_ENDIAN
+
+#endif /* bits/endianness.h */
diff --git a/sysdeps/loongarch/bits/link.h b/sysdeps/loongarch/bits/link.h
new file mode 100644
index 0000000000..0e5fb2aaab
--- /dev/null
+++ b/sysdeps/loongarch/bits/link.h
@@ -0,0 +1,58 @@
+/* Machine-specific declarations for dynamic linker interface.  LoongArch
+   version.  Copyright (C) 2021 Free Software Foundation, Inc.  This
+   file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _LINK_H
+#error "Never include <bits/link.h> directly; use <link.h> instead."
+#endif
+
+typedef struct La_loongarch_regs
+{
+  unsigned long int lr_reg[8]; /* a0 - a7 */
+  double lr_fpreg[8];	       /* fa0 - fa7 */
+  unsigned long int lr_ra;
+  unsigned long int lr_sp;
+} La_loongarch_regs;
+
+/* Return values for calls from PLT on LoongArch.  */
+typedef struct La_loongarch_retval
+{
+  unsigned long int lrv_a0;
+  unsigned long int lrv_a1;
+  double lrv_fa0;
+  double lrv_fa1;
+} La_loongarch_retval;
+
+__BEGIN_DECLS
+
+extern ElfW (Addr) la_loongarch_gnu_pltenter (ElfW (Sym) * __sym,
+					      unsigned int __ndx,
+					      uintptr_t *__refcook,
+					      uintptr_t *__defcook,
+					      La_loongarch_regs *__regs,
+					      unsigned int *__flags,
+					      const char *__symname,
+					      long int *__framesizep);
+extern unsigned int la_loongarch_gnu_pltexit (ElfW (Sym) * __sym,
+					      unsigned int __ndx,
+					      uintptr_t *__refcook,
+					      uintptr_t *__defcook,
+					      const La_loongarch_regs *__inregs,
+					      La_loongarch_retval *__outregs,
+					      const char *__symname);
+
+__END_DECLS
diff --git a/sysdeps/loongarch/bits/setjmp.h b/sysdeps/loongarch/bits/setjmp.h
new file mode 100644
index 0000000000..4b1440e07d
--- /dev/null
+++ b/sysdeps/loongarch/bits/setjmp.h
@@ -0,0 +1,39 @@
+/* Define the machine-dependent type `jmp_buf'.  LoongArch version.
+   Copyright (C) 2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _LOONGARCH_BITS_SETJMP_H
+#define _LOONGARCH_BITS_SETJMP_H
+
+typedef struct __jmp_buf_internal_tag
+{
+  /* Program counter.  */
+  long int __pc;
+  /* Stack pointer.  */
+  long int __sp;
+  /* Reserved */
+  long int __x;
+  /* Frame pointer.  */
+  long int __fp;
+  /* Callee-saved registers.  */
+  long int __regs[9];
+
+  /* Callee-saved floating point registers.  */
+  double __fpregs[8];
+} __jmp_buf[1];
+
+#endif /* _LOONGARCH_BITS_SETJMP_H */
diff --git a/sysdeps/loongarch/bits/wordsize.h b/sysdeps/loongarch/bits/wordsize.h
new file mode 100644
index 0000000000..e12709cc65
--- /dev/null
+++ b/sysdeps/loongarch/bits/wordsize.h
@@ -0,0 +1,25 @@
+/* Determine the wordsize from the preprocessor defines.  LoongArch version
+   Copyright (C) 2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifdef __LP64__
+#define __WORDSIZE 64
+#else
+#define __WORDSIZE 32
+#endif
+
+#define __WORDSIZE_TIME64_COMPAT32 0
diff --git a/sysdeps/loongarch/dl-machine.h b/sysdeps/loongarch/dl-machine.h
new file mode 100644
index 0000000000..5f2656e574
--- /dev/null
+++ b/sysdeps/loongarch/dl-machine.h
@@ -0,0 +1,365 @@
+/* Machine-dependent ELF dynamic relocation inline functions.  LoongArch
+   version.  Copyright (C) 2021 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef dl_machine_h
+#define dl_machine_h
+
+#define ELF_MACHINE_NAME "LoongArch"
+
+#include <entry.h>
+#include <elf/elf.h>
+#include <sys/asm.h>
+#include <dl-tls.h>
+
+#ifndef _RTLD_PROLOGUE
+# define _RTLD_PROLOGUE(entry)					\
+	".globl\t" __STRING (entry) "\n\t"			\
+	".type\t" __STRING (entry) ", @function\n\t"		\
+	CFI_STARTPROC "\n"					\
+	__STRING (entry) ":\n"
+#endif
+
+#ifndef _RTLD_EPILOGUE
+# define _RTLD_EPILOGUE(entry)					\
+	CFI_ENDPROC "\n\t"					\
+	".size\t" __STRING (entry) ", . - " __STRING (entry) "\n"
+#endif
+
+#define ELF_MACHINE_JMP_SLOT R_LARCH_JUMP_SLOT
+#define ELF_MACHINE_IRELATIVE R_LARCH_IRELATIVE
+
+#define elf_machine_type_class(type)				\
+  ((ELF_RTYPE_CLASS_PLT * ((type) == ELF_MACHINE_JMP_SLOT	\
+     || (__WORDSIZE == 32 && (type) == R_LARCH_TLS_DTPREL32)	\
+     || (__WORDSIZE == 32 && (type) == R_LARCH_TLS_DTPMOD32)	\
+     || (__WORDSIZE == 32 && (type) == R_LARCH_TLS_TPREL32)	\
+     || (__WORDSIZE == 64 && (type) == R_LARCH_TLS_DTPREL64)	\
+     || (__WORDSIZE == 64 && (type) == R_LARCH_TLS_DTPMOD64)	\
+     || (__WORDSIZE == 64 && (type) == R_LARCH_TLS_TPREL64)))	\
+   | (ELF_RTYPE_CLASS_COPY * ((type) == R_LARCH_COPY)))
+
+#define ELF_MACHINE_NO_REL 1
+#define ELF_MACHINE_NO_RELA 0
+
+/* Return nonzero iff ELF header is compatible with the running host.  */
+static inline int __attribute_used__
+elf_machine_matches_host (const ElfW (Ehdr) * ehdr)
+{
+  /* We can only run LoongArch binaries.  */
+  if (ehdr->e_machine != EM_LOONGARCH)
+    return 0;
+
+#ifdef _ABILP64
+  if ((ehdr->e_flags & EF_LARCH_ABI) != EF_LARCH_ABI_LP64)
+#elif defined _ABILP32
+  if ((ehdr->e_flags & EF_LARCH_ABI) != EF_LARCH_ABI_LP32)
+#else
+#error "Unknown ABI"
+#endif
+    return 0;
+
+  return 1;
+}
+
+/* Runtime address of .got */
+#define _GLOBAL_OFFSET_TABLE_ \
+  ({ \
+    ElfW (Addr) * r; \
+    asm("la.pcrel %0, _GLOBAL_OFFSET_TABLE_" : "=r"(r)); \
+    r; \
+  })
+
+/* Return the link-time address of _DYNAMIC.  */
+static inline ElfW (Addr) elf_machine_dynamic (void)
+{
+  return _GLOBAL_OFFSET_TABLE_[0];
+}
+
+#define STRINGXP(X) __STRING (X)
+#define STRINGXV(X) STRINGV_ (X)
+#define STRINGV_(...) #__VA_ARGS__
+
+/* Return the run-time load address of the shared object.  */
+static inline ElfW (Addr) elf_machine_load_address (void)
+{
+  ElfW (Addr) got_linktime_addr;
+  asm("la.got %0, _GLOBAL_OFFSET_TABLE_"
+      /* Link-time address in GOT entry before runtime relocation */
+      : "=r"(got_linktime_addr));
+  return (ElfW (Addr)) _GLOBAL_OFFSET_TABLE_ - got_linktime_addr;
+}
+
+/* Initial entry point code for the dynamic linker.
+   The C function `_dl_start' is the real entry point;
+   its return value is the user program's entry point.  */
+
+#define RTLD_START \
+  asm(".text\n\
+      " _RTLD_PROLOGUE (ENTRY_POINT) "\
+      .cfi_label .Ldummy   \n\
+      " CFI_UNDEFINED (1) "   \n\
+      or	$a0, $sp, $zero   \n\
+      bl	_dl_start   \n\
+      # Stash user entry point in s0.   \n\
+      or	$s0, $v0, $zero   \n\
+      # See if we were run as a command with the executable file   \n\
+      # name as an extra leading argument.   \n\
+      la	$a0, _dl_skip_args   \n\
+      ld.w	$a0, $a0, 0   \n\
+      # Load the original argument count.   \n\
+      ld.d	$a1, $sp, 0   \n\
+      # Subtract _dl_skip_args from it.   \n\
+      sub.d	$a1, $a1, $a0   \n\
+      # Adjust the stack pointer to skip _dl_skip_args words.   \n\
+      slli.d	$a0, $a0, 3   \n\
+      add.d	$sp, $sp, $a0   \n\
+      # Save back the modified argument count.   \n\
+      st.d	$a1, $sp, 0   \n\
+      # Call _dl_init (struct link_map *main_map, int argc, char **argv, \
+		       char **env)    \n\
+      la	$a0, _rtld_local   \n\
+      ld.d	$a0, $a0, 0   \n\
+      addi.d	$a2, $sp, 8   \n\
+      slli.d	$a3, $a1, 3   \n\
+      add.d	$a3, $a3, $a2   \n\
+      addi.d	$a3, $a3, 8   \n\
+      # Adjust $sp for 16-aligned   \n\
+      srli.d  $t0, $sp, 4   \n\
+      slli.d  $t0, $t0, 4   \n\
+      ori	$t1, $sp, 0   \n\
+      addi.d  $sp, $t0, -32   \n\
+      st.d	$t1, $sp, 24   \n\
+      # Call the function to run the initializers.   \n\
+      bl	_dl_init   \n\
+      # Pass our finalizer function to _start.   \n\
+      ld.d    $sp, $sp, 24   \n\
+      la	$a0, _dl_fini   \n\
+      # Jump to the user entry point.   \n\
+      jirl	$zero, $s0, 0   \n\
+      " _RTLD_EPILOGUE (ENTRY_POINT) "\
+      .previous");
+
+/* Names of the architecture-specific auditing callback functions.  */
+#define ARCH_LA_PLTENTER loongarch_gnu_pltenter
+#define ARCH_LA_PLTEXIT loongarch_gnu_pltexit
+
+/* Bias .got.plt entry by the offset requested by the PLT header.  */
+#define elf_machine_plt_value(map, reloc, value) (value)
+
+static inline ElfW (Addr)
+  elf_machine_fixup_plt (struct link_map *map, lookup_t t,
+			 const ElfW (Sym) * refsym, const ElfW (Sym) * sym,
+			 const ElfW (Rela) * reloc, ElfW (Addr) * reloc_addr,
+			 ElfW (Addr) value)
+{
+  return *reloc_addr = value;
+}
+
+#endif /* !dl_machine_h */
+
+#ifdef RESOLVE_MAP
+
+/* Perform a relocation described by R_INFO at the location pointed to
+   by RELOC_ADDR.  SYM is the relocation symbol specified by R_INFO and
+   MAP is the object containing the reloc.  */
+
+auto inline void __attribute__ ((always_inline))
+elf_machine_rela (struct link_map *map, const ElfW (Rela) * reloc,
+		  const ElfW (Sym) * sym,
+		  const struct r_found_version *version,
+		  void *const reloc_addr, int skip_ifunc)
+{
+  ElfW (Addr) r_info = reloc->r_info;
+  const unsigned long int r_type = ELFW (R_TYPE) (r_info);
+  ElfW (Addr) *addr_field = (ElfW (Addr) *) reloc_addr;
+  const ElfW (Sym) *const __attribute__ ((unused)) refsym = sym;
+  struct link_map *sym_map = RESOLVE_MAP (&sym, version, r_type);
+  ElfW (Addr) value = 0;
+  if (sym_map != NULL)
+    value = SYMBOL_ADDRESS (sym_map, sym, true) + reloc->r_addend;
+
+  if (sym != NULL
+      && __builtin_expect (ELFW (ST_TYPE) (sym->st_info) == STT_GNU_IFUNC, 0)
+      && __builtin_expect (sym->st_shndx != SHN_UNDEF, 1)
+      && __builtin_expect (!skip_ifunc, 1))
+    value = ((ElfW (Addr) (*) (int)) value) (GLRO (dl_hwcap));
+
+  switch (r_type)
+    {
+#ifndef RTLD_BOOTSTRAP
+    case __WORDSIZE == 64 ? R_LARCH_TLS_DTPMOD64:
+    R_LARCH_TLS_DTPMOD32:
+      if (sym_map)
+	*addr_field = sym_map->l_tls_modid;
+      break;
+
+    case __WORDSIZE == 64 ? R_LARCH_TLS_DTPREL64:
+    R_LARCH_TLS_DTPREL32:
+      if (sym != NULL)
+	*addr_field = TLS_DTPREL_VALUE (sym) + reloc->r_addend;
+      break;
+
+    case __WORDSIZE == 64 ? R_LARCH_TLS_TPREL64:
+    R_LARCH_TLS_TPREL32:
+      if (sym != NULL)
+	{
+	  CHECK_STATIC_TLS (map, sym_map);
+	  *addr_field = TLS_TPREL_VALUE (sym_map, sym) + reloc->r_addend;
+	}
+      break;
+
+    case R_LARCH_COPY:
+      {
+	if (__glibc_unlikely (sym == NULL))
+	  /* This can happen in trace mode if an object could not be
+	     found.  */
+	  break;
+
+	/* Handle TLS copy relocations.  */
+	if (__glibc_unlikely (ELFW (ST_TYPE) (sym->st_info) == STT_TLS))
+	  {
+	    /* There's nothing to do if the symbol is in .tbss.  */
+	    if (__glibc_likely (sym->st_value
+				>= sym_map->l_tls_initimage_size))
+	      break;
+	    value += (ElfW (Addr)) sym_map->l_tls_initimage - sym_map->l_addr;
+	  }
+
+	size_t size = sym->st_size;
+	if (__glibc_unlikely (sym->st_size != refsym->st_size))
+	  {
+	    const char *strtab = (const void *) D_PTR (map, l_info[DT_STRTAB]);
+	    if (sym->st_size > refsym->st_size)
+	      size = refsym->st_size;
+	    if (sym->st_size > refsym->st_size || GLRO (dl_verbose))
+	      _dl_error_printf ("\
+  %s: Symbol `%s' has different size in shared object, consider re-linking\n",
+				rtld_progname ?: "<program name unknown>",
+				strtab + refsym->st_name);
+	  }
+
+	memcpy (reloc_addr, (void *) value, size);
+	break;
+      }
+#endif
+
+#if !defined RTLD_BOOTSTRAP || !defined HAVE_Z_COMBRELOC
+    case R_LARCH_RELATIVE:
+      {
+#if !defined RTLD_BOOTSTRAP && !defined HAVE_Z_COMBRELOC
+	/* This is defined in rtld.c, but nowhere in the static libc.a;
+	   make the reference weak so static programs can still link.
+	   This declaration cannot be done when compiling rtld.c
+	   (i.e. #ifdef RTLD_BOOTSTRAP) because rtld.c contains the
+	   common defn for _dl_rtld_map, which is incompatible with a
+	   weak decl in the same file.  */
+#ifndef SHARED
+	weak_extern (GL (dl_rtld_map));
+#endif
+	if (map != &GL (dl_rtld_map)) /* Already done in rtld itself.  */
+#endif
+	  *addr_field = map->l_addr + reloc->r_addend;
+	break;
+      }
+#endif
+
+    case R_LARCH_JUMP_SLOT:
+    case __WORDSIZE == 64 ? R_LARCH_64:
+    R_LARCH_32:
+      *addr_field = value;
+      break;
+
+    case R_LARCH_IRELATIVE:
+      value = map->l_addr + reloc->r_addend;
+      value = ((ElfW (Addr) (*) (void)) value) ();
+      *addr_field = value;
+      break;
+
+    case R_LARCH_NONE:
+      break;
+
+    default:
+      _dl_reloc_bad_type (map, r_type, 0);
+      break;
+    }
+}
+
+auto inline void __attribute__ ((always_inline))
+elf_machine_rela_relative (ElfW (Addr) l_addr, const ElfW (Rela) * reloc,
+			   void *const reloc_addr)
+{
+  *(ElfW (Addr) *) reloc_addr = l_addr + reloc->r_addend;
+}
+
+auto inline void __attribute__ ((always_inline))
+elf_machine_lazy_rel (struct link_map *map, ElfW (Addr) l_addr,
+		      const ElfW (Rela) * reloc, int skip_ifunc)
+{
+  ElfW (Addr) *const reloc_addr = (void *) (l_addr + reloc->r_offset);
+  const unsigned int r_type = ELFW (R_TYPE) (reloc->r_info);
+
+  /* Check for unexpected PLT reloc type.  */
+  if (__glibc_likely (r_type == R_LARCH_JUMP_SLOT))
+    {
+      if (__glibc_unlikely (map->l_mach.plt == 0))
+	{
+	  if (l_addr)
+	    *reloc_addr += l_addr;
+	}
+      else
+	*reloc_addr = map->l_mach.plt;
+    }
+  else if (__glibc_unlikely (r_type == R_LARCH_IRELATIVE))
+    {
+      ElfW (Addr) *value = (void *) (l_addr + reloc->r_addend);
+      if (__glibc_likely (!skip_ifunc))
+	value = (ElfW (Addr) *) ((ElfW (Addr) (*) (void)) value) ();
+      *reloc_addr = (ElfW (Addr)) value;
+    }
+  else
+    _dl_reloc_bad_type (map, r_type, 1);
+}
+
+/* Set up the loaded object described by L so its stub function
+   will jump to the on-demand fixup code __dl_runtime_resolve.  */
+
+auto inline int __attribute__ ((always_inline))
+elf_machine_runtime_setup (struct link_map *l, int lazy, int profile)
+{
+#ifndef RTLD_BOOTSTRAP
+  /* If using PLTs, fill in the first two entries of .got.plt.  */
+  if (l->l_info[DT_JMPREL])
+    {
+      extern void _dl_runtime_resolve (void)
+	__attribute__ ((visibility ("hidden")));
+      ElfW (Addr) *gotplt = (ElfW (Addr) *) D_PTR (l, l_info[DT_PLTGOT]);
+      /* If a library is prelinked but we have to relocate anyway,
+	 we have to be able to undo the prelinking of .got.plt.
+	 The prelinker saved the address of .plt for us here.  */
+      if (gotplt[1])
+	l->l_mach.plt = gotplt[1] + l->l_addr;
+      gotplt[0] = (ElfW (Addr)) & _dl_runtime_resolve;
+      gotplt[1] = (ElfW (Addr)) l;
+    }
+#endif
+
+  return lazy;
+}
+
+#endif /* RESOLVE_MAP */
diff --git a/sysdeps/loongarch/dl-trampoline.S b/sysdeps/loongarch/dl-trampoline.S
new file mode 100644
index 0000000000..2343a18a94
--- /dev/null
+++ b/sysdeps/loongarch/dl-trampoline.S
@@ -0,0 +1,108 @@
+/* PLT trampolines.  LoongArch version.
+   Copyright (C) 2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include <sys/asm.h>
+
+/* Assembler veneer called from the PLT header code for lazy loading.
+   The PLT header passes its own args in t0-t2.  */
+
+#ifdef __loongarch_soft_float
+# define FRAME_SIZE (-((-10 * SZREG) & ALMASK))
+#else
+# define FRAME_SIZE (-((-10 * SZREG - 8 * SZFREG) & ALMASK))
+#endif
+
+ENTRY (_dl_runtime_resolve)
+  # Save arguments to stack.
+
+#ifdef __loongarch64
+    addi.d  sp, sp, -FRAME_SIZE
+#elif defined __loongarch32
+    addi.w  sp, sp, -FRAME_SIZE
+#endif
+
+    REG_S   ra, sp, 9*SZREG
+    REG_S   a0, sp, 1*SZREG
+    REG_S   a1, sp, 2*SZREG
+    REG_S   a2, sp, 3*SZREG
+    REG_S   a3, sp, 4*SZREG
+    REG_S   a4, sp, 5*SZREG
+    REG_S   a5, sp, 6*SZREG
+    REG_S   a6, sp, 7*SZREG
+    REG_S   a7, sp, 8*SZREG
+
+#ifndef __loongarch_soft_float
+    FREG_S  fa0, sp, 10*SZREG + 0*SZFREG
+    FREG_S  fa1, sp, 10*SZREG + 1*SZFREG
+    FREG_S  fa2, sp, 10*SZREG + 2*SZFREG
+    FREG_S  fa3, sp, 10*SZREG + 3*SZFREG
+    FREG_S  fa4, sp, 10*SZREG + 4*SZFREG
+    FREG_S  fa5, sp, 10*SZREG + 5*SZFREG
+    FREG_S  fa6, sp, 10*SZREG + 6*SZFREG
+    FREG_S  fa7, sp, 10*SZREG + 7*SZFREG
+#endif
+
+  # Update .got.plt and obtain runtime address of callee.
+#ifdef __loongarch64
+    slli.d  a1, t1, 1
+    or      a0, t0, zero
+    add.d   a1, a1, t1
+    la      a2, _dl_fixup
+    jirl    ra, a2, 0
+    or      t1, v0, zero
+#elif defined __loongarch32
+    slli.w  a1, t1, 1
+    or      a0, t0, zero
+    add.w   a1, a1, t1
+    la      a2, _dl_fixup
+    jirl    ra, a2, 0
+    or      t1, v0, zero
+#endif
+
+  # Restore arguments from stack.
+    REG_L   ra, sp, 9*SZREG
+    REG_L   a0, sp, 1*SZREG
+    REG_L   a1, sp, 2*SZREG
+    REG_L   a2, sp, 3*SZREG
+    REG_L   a3, sp, 4*SZREG
+    REG_L   a4, sp, 5*SZREG
+    REG_L   a5, sp, 6*SZREG
+    REG_L   a6, sp, 7*SZREG
+    REG_L   a7, sp, 8*SZREG
+
+#ifndef __loongarch_soft_float
+    FREG_L  fa0, sp, 10*SZREG + 0*SZFREG
+    FREG_L  fa1, sp, 10*SZREG + 1*SZFREG
+    FREG_L  fa2, sp, 10*SZREG + 2*SZFREG
+    FREG_L  fa3, sp, 10*SZREG + 3*SZFREG
+    FREG_L  fa4, sp, 10*SZREG + 4*SZFREG
+    FREG_L  fa5, sp, 10*SZREG + 5*SZFREG
+    FREG_L  fa6, sp, 10*SZREG + 6*SZFREG
+    FREG_L  fa7, sp, 10*SZREG + 7*SZFREG
+#endif
+
+#ifdef __loongarch64
+    addi.d  sp, sp, FRAME_SIZE
+#elif defined __loongarch32
+    addi.w  sp, sp, FRAME_SIZE
+#endif
+
+  # Invoke the callee.
+    jirl    zero, t1, 0
+END (_dl_runtime_resolve)
diff --git a/sysdeps/loongarch/gccframe.h b/sysdeps/loongarch/gccframe.h
new file mode 100644
index 0000000000..01d381e0b3
--- /dev/null
+++ b/sysdeps/loongarch/gccframe.h
@@ -0,0 +1,21 @@
+/* Definition of object in frame unwind info.  LoongArch version.
+   Copyright (C) 2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#define FIRST_PSEUDO_REGISTER 74
+
+#include <sysdeps/generic/gccframe.h>
diff --git a/sysdeps/loongarch/jmpbuf-offsets.h b/sysdeps/loongarch/jmpbuf-offsets.h
new file mode 100644
index 0000000000..d70e9f0b7e
--- /dev/null
+++ b/sysdeps/loongarch/jmpbuf-offsets.h
@@ -0,0 +1,22 @@
+/* Private macros for accessing __jmp_buf contents.  LoongArch version.
+   Copyright (C) 2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <jmpbuf-unwind.h>
+
+/* Helper for generic ____longjmp_chk().  */
+#define JB_FRAME_ADDRESS(buf) ((void *) _jmpbuf_sp (buf))
diff --git a/sysdeps/loongarch/jmpbuf-unwind.h b/sysdeps/loongarch/jmpbuf-unwind.h
new file mode 100644
index 0000000000..2810853cf6
--- /dev/null
+++ b/sysdeps/loongarch/jmpbuf-unwind.h
@@ -0,0 +1,44 @@
+/* Copyright (C) 2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <setjmp.h>
+#include <stdint.h>
+#include <unwind.h>
+#include <sysdep.h>
+
+/* Test if longjmp to JMPBUF would unwind the frame
+   containing a local variable at ADDRESS.  */
+#define _JMPBUF_UNWINDS(jmpbuf, address, demangle) \
+  ((void *) (address) < (void *) demangle ((jmpbuf)[0].__sp))
+
+#define _JMPBUF_CFA_UNWINDS_ADJ(_jmpbuf, _context, _adj) \
+  _JMPBUF_UNWINDS_ADJ (_jmpbuf, (void *) _Unwind_GetCFA (_context), _adj)
+
+static inline uintptr_t __attribute__ ((unused)) _jmpbuf_sp (__jmp_buf regs)
+{
+  uintptr_t sp = regs[0].__sp;
+#ifdef PTR_DEMANGLE
+  PTR_DEMANGLE (sp);
+#endif
+  return sp;
+}
+
+#define _JMPBUF_UNWINDS_ADJ(_jmpbuf, _address, _adj) \
+  ((uintptr_t) (_address) - (_adj) < _jmpbuf_sp (_jmpbuf) - (_adj))
+
+/* We use the normal longjmp for unwinding.  */
+#define __libc_unwind_longjmp(buf, val) __libc_longjmp (buf, val)
diff --git a/sysdeps/loongarch/ldsodefs.h b/sysdeps/loongarch/ldsodefs.h
new file mode 100644
index 0000000000..0fd3bbd2c7
--- /dev/null
+++ b/sysdeps/loongarch/ldsodefs.h
@@ -0,0 +1,46 @@
+/* Run-time dynamic linker data structures for loaded ELF shared objects.
+   LoongArch version.
+   Copyright (C) 2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _LOONGARCH_LDSODEFS_H
+#define _LOONGARCH_LDSODEFS_H 1
+
+#include <elf.h>
+
+struct La_loongarch_regs;
+struct La_loongarch_retval;
+
+#define ARCH_PLTENTER_MEMBERS \
+  ElfW (Addr) (*loongarch_gnu_pltenter) (ElfW (Sym) *, unsigned int, \
+					 uintptr_t *, uintptr_t *, \
+					 const struct La_loongarch_regs *, \
+					 unsigned int *, const char *name, \
+					 long int *framesizep);
+
+#define ARCH_PLTEXIT_MEMBERS \
+  unsigned int (*loongarch_gnu_pltexit) (ElfW (Sym) *, unsigned int, \
+		uintptr_t *, uintptr_t *, const struct La_loongarch_regs *, \
+		struct La_loongarch_retval *, const char *);
+
+/* The LoongArch ABI specifies that the dynamic section has to be read-only.  */
+
+#define DL_RO_DYN_SECTION 1
+
+#include_next <ldsodefs.h>
+
+#endif
diff --git a/sysdeps/loongarch/linkmap.h b/sysdeps/loongarch/linkmap.h
new file mode 100644
index 0000000000..f88ce50162
--- /dev/null
+++ b/sysdeps/loongarch/linkmap.h
@@ -0,0 +1,4 @@
+struct link_map_machine
+{
+  ElfW (Addr) plt; /* Address of .plt.  */
+};
diff --git a/sysdeps/loongarch/machine-gmon.h b/sysdeps/loongarch/machine-gmon.h
new file mode 100644
index 0000000000..d330fd6e79
--- /dev/null
+++ b/sysdeps/loongarch/machine-gmon.h
@@ -0,0 +1,37 @@
+/* LoongArch definitions for profiling support.
+   Copyright (C) 2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* Accept 'frompc' address as argument from the function that calls
+   _mcount for profiling.  Use  __builtin_return_address (0)
+   for the 'selfpc' address.  */
+
+#include <sysdep.h>
+
+static void mcount_internal (unsigned long int frompc,
+			     unsigned long int selfpc);
+
+#define _MCOUNT_DECL(frompc, selfpc) \
+  static inline void mcount_internal (unsigned long int frompc, \
+				      unsigned long int selfpc)
+
+#define MCOUNT \
+  void _mcount (void *frompc) \
+  { \
+    mcount_internal ((unsigned long int) frompc, \
+		     (unsigned long int) RETURN_ADDRESS (0)); \
+  }
diff --git a/sysdeps/loongarch/memusage.h b/sysdeps/loongarch/memusage.h
new file mode 100644
index 0000000000..c79d0ecb82
--- /dev/null
+++ b/sysdeps/loongarch/memusage.h
@@ -0,0 +1,25 @@
+/* Machine-specific definitions for memory usage profiling, LoongArch version.
+   Copyright (C) 2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#define GETSP() \
+  ({ \
+    register uintptr_t stack_ptr asm("$sp"); \
+    stack_ptr; \
+  })
+
+#include <sysdeps/generic/memusage.h>
diff --git a/sysdeps/loongarch/setjmp.S b/sysdeps/loongarch/setjmp.S
new file mode 100644
index 0000000000..278c8f38e2
--- /dev/null
+++ b/sysdeps/loongarch/setjmp.S
@@ -0,0 +1,53 @@
+/* setjmp for LoongArch.
+   Copyright (C) 2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include <sys/asm.h>
+
+ENTRY (__sigsetjmp)
+  REG_S ra, a0, 0*SZREG
+  REG_S sp, a0, 1*SZREG
+  REG_S x,  a0, 2*SZREG
+  REG_S fp, a0, 3*SZREG
+  REG_S s0, a0, 4*SZREG
+  REG_S s1, a0, 5*SZREG
+  REG_S s2, a0, 6*SZREG
+  REG_S s3, a0, 7*SZREG
+  REG_S s4, a0, 8*SZREG
+  REG_S s5, a0, 9*SZREG
+  REG_S s6, a0, 10*SZREG
+  REG_S s7, a0, 11*SZREG
+  REG_S s8, a0, 12*SZREG
+
+  FREG_S $f24, a0, 13*SZREG + 0*SZFREG
+  FREG_S $f25, a0, 13*SZREG + 1*SZFREG
+  FREG_S $f26, a0, 13*SZREG + 2*SZFREG
+  FREG_S $f27, a0, 13*SZREG + 3*SZFREG
+  FREG_S $f28, a0, 13*SZREG + 4*SZFREG
+  FREG_S $f29, a0, 13*SZREG + 5*SZFREG
+  FREG_S $f30, a0, 13*SZREG + 6*SZFREG
+  FREG_S $f31, a0, 13*SZREG + 7*SZFREG
+
+#if IS_IN(rtld)
+  li.w  v0, 0
+  jirl  zero,ra,0
+#else
+  b     C_SYMBOL_NAME(__sigjmp_save)
+#endif
+END (__sigsetjmp)
+hidden_def (__sigsetjmp)
diff --git a/sysdeps/loongarch/sotruss-lib.c b/sysdeps/loongarch/sotruss-lib.c
new file mode 100644
index 0000000000..8a7a438ba0
--- /dev/null
+++ b/sysdeps/loongarch/sotruss-lib.c
@@ -0,0 +1,50 @@
+/* Override generic sotruss-lib.c to define actual functions for LoongArch.
+   Copyright (C) 2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#define HAVE_ARCH_PLTENTER
+#define HAVE_ARCH_PLTEXIT
+
+#include <elf/sotruss-lib.c>
+
+ElfW (Addr)
+la_loongarch_gnu_pltenter (ElfW (Sym) * sym __attribute__ ((unused)),
+			   unsigned int ndx __attribute__ ((unused)),
+			   uintptr_t *refcook, uintptr_t *defcook,
+			   La_loongarch_regs *regs, unsigned int *flags,
+			   const char *symname, long int *framesizep)
+{
+  print_enter (refcook, defcook, symname, regs->lr_reg[0], regs->lr_reg[1],
+		   regs->lr_reg[2], *flags);
+
+  /* No need to copy anything, we will not need the parameters in any case.  */
+  *framesizep = 0;
+
+  return sym->st_value;
+}
+
+unsigned int
+la_loongarch_gnu_pltexit (ElfW (Sym) * sym, unsigned int ndx,
+			  uintptr_t *refcook, uintptr_t *defcook,
+			  const struct La_loongarch_regs *inregs,
+			  struct La_loongarch_retval *outregs,
+			  const char *symname)
+{
+  print_exit (refcook, defcook, symname, outregs->lrv_a0);
+
+  return 0;
+}
diff --git a/sysdeps/loongarch/start.S b/sysdeps/loongarch/start.S
new file mode 100644
index 0000000000..f1a8b03b2f
--- /dev/null
+++ b/sysdeps/loongarch/start.S
@@ -0,0 +1,71 @@
+/* Startup code compliant to the ELF LoongArch ABI.
+   Copyright (C) 2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   Contributed by Loongson Technology Corporation Limited.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#define __ASSEMBLY__ 1
+#include <entry.h>
+#include <sys/asm.h>
+
+/* The entry point's job is to call __libc_start_main.  Per the ABI,
+   a0 contains the address of a function to be passed to atexit.
+   __libc_start_main wants this in a5.  */
+
+/*
+int
+__libc_start_main (int (*main) (int, char **, char **),
+		   int argc,
+		   char **argv,
+		   __typeof (main) init,
+		   void (*fini) (void),
+		   void (*rtld_fini) (void),
+		   void *stack_end);
+*/
+
+ENTRY (ENTRY_POINT)
+    /* Terminate call stack by noting ra is undefined.  Use a dummy
+       .cfi_label to force starting the FDE.  */
+    .cfi_label .Ldummy
+    cfi_undefined (1)
+    or      a5, a0, zero /* rtld_fini */
+
+    /* We must get symbol main through GOT table, since main may not be local.
+       For instance: googletest defines main in dynamic library.  */
+    la.got  a0, t0, main
+#ifdef __loongarch64
+    ld.d    a1, sp, 0
+    addi.d  a2, sp, SZREG
+#elif defined __loongarch32
+    ld.w    a1, sp, 0
+    addi.w  a2, sp, SZREG
+#endif
+    /* Adjust $sp for 16-aligned */
+    srli.d  sp, sp, 4
+    slli.d  sp, sp, 4
+
+    move    a3, zero /* used to be init */
+    move    a4, zero /* used to be fini */
+    or      a6, sp, zero /* stack_end */
+
+    la.got  ra, t0, __libc_start_main
+    jirl    ra, ra, 0
+
+    la.got  ra, t0, abort
+    jirl    ra, ra, 0
+END (ENTRY_POINT)
+
diff --git a/sysdeps/loongarch/sys/asm.h b/sysdeps/loongarch/sys/asm.h
new file mode 100644
index 0000000000..35ab3892fa
--- /dev/null
+++ b/sysdeps/loongarch/sys/asm.h
@@ -0,0 +1,67 @@
+/* Copyright (C) 2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   Contributed by Loongson Technology Corporation Limited.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_ASM_H
+#define _SYS_ASM_H
+
+#include <sys/regdef.h>
+#include <sysdeps/generic/sysdep.h>
+
+/* Macros to handle different pointer/register sizes for 32/64-bit code.  */
+#if _LOONGARCH_SIM == _ABILP64
+#define PTRLOG 3
+#define SZREG 8
+#define SZFREG 8
+#define REG_L ld.d
+#define REG_S st.d
+#define FREG_L fld.d
+#define FREG_S fst.d
+#elif _LOONGARCH_SIM == _ABILP32
+#define PTRLOG 2
+#define SZREG 4
+#define SZFREG 4
+#define REG_L ld.w
+#define REG_S st.w
+#define FREG_L fld.w
+#define FREG_S fst.w
+#else
+#error _LOONGARCH_SIM must equal _ABILP32 or _ABILP64
+#endif
+
+/* Declare leaf routine.  */
+#define LEAF(symbol) \
+  .text; \
+  .globl symbol; \
+  .align 3; \
+  cfi_startproc; \
+  .type symbol, @function; \
+  symbol:
+
+#define ENTRY(symbol) LEAF (symbol)
+
+/* Mark end of function.  */
+#undef END
+#define END(function) \
+  cfi_endproc; \
+  .size function, .- function;
+
+/* Stack alignment.  */
+#define ALMASK ~15
+
+#endif /* sys/asm.h */
diff --git a/sysdeps/loongarch/tls-macros.h b/sysdeps/loongarch/tls-macros.h
new file mode 100644
index 0000000000..af5eb6b700
--- /dev/null
+++ b/sysdeps/loongarch/tls-macros.h
@@ -0,0 +1,49 @@
+/* Macros to support TLS testing in times of missing compiler support.
+   Copyright (C) 2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#include <sys/cdefs.h>
+#include <sys/asm.h>
+#include <sysdep.h>
+#include "dl-tls.h"
+
+#define TLS_GD(x) \
+  ({ \
+    void *__result; \
+    asm("la.tls.gd %0, " #x "\n\t" : "=r"(__result)); \
+    __tls_get_addr (__result); \
+  })
+
+#define TLS_LD(x) TLS_GD (x)
+
+#define TLS_IE(x) \
+  ({ \
+    void *__result; \
+    asm("la.tls.ie %0, " #x "\n\t" \
+	"add.d %0, %0, $tp\n\t" \
+	: "=r"(__result)); \
+    __result; \
+  })
+
+#define TLS_LE(x) \
+  ({ \
+    void *__result; \
+    asm("la.tls.le %0, " #x "\n\t" \
+	"add.d %0, %0, $tp\n\t" \
+	: "=r"(__result)); \
+    __result; \
+  })
diff --git a/sysdeps/loongarch/tst-audit.h b/sysdeps/loongarch/tst-audit.h
new file mode 100644
index 0000000000..725efc8690
--- /dev/null
+++ b/sysdeps/loongarch/tst-audit.h
@@ -0,0 +1,23 @@
+/* Definitions for testing PLT entry/exit auditing.  LoongArch version.
+   Copyright (C) 2021 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+#define pltenter la_loongarch_gnu_pltenter
+#define pltexit la_loongarch_gnu_pltexit
+#define La_regs La_loongarch_regs
+#define La_retval La_loongarch_retval
+#define int_retval lrv_a0
diff --git a/sysdeps/unix/sysv/linux/loongarch/localplt.data b/sysdeps/unix/sysv/linux/loongarch/localplt.data
new file mode 100644
index 0000000000..14c02cb2d6
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/loongarch/localplt.data
@@ -0,0 +1,19 @@
+# See scripts/check-localplt.awk for how this file is processed.
+# PLT use is required for the malloc family and for matherr because
+# users can define their own functions and have library internals call them.
+libc.so: calloc
+libc.so: free
+libc.so: malloc
+libc.so: memalign
+libc.so: realloc
+# The main malloc is interposed into the dynamic linker, for
+# allocations after the initial link (when dlopen is used).
+ld.so: malloc
+ld.so: calloc
+ld.so: realloc
+ld.so: free
+# The TLS-enabled version of these functions is interposed from libc.so.
+ld.so: _dl_signal_error
+ld.so: _dl_catch_error
+ld.so: _dl_signal_exception
+ld.so: _dl_catch_exception
diff --git a/sysdeps/unix/sysv/linux/loongarch/lp64/jmp_buf-macros.h b/sysdeps/unix/sysv/linux/loongarch/lp64/jmp_buf-macros.h
new file mode 100644
index 0000000000..b1422273c5
--- /dev/null
+++ b/sysdeps/unix/sysv/linux/loongarch/lp64/jmp_buf-macros.h
@@ -0,0 +1,43 @@
+/* Copyright (C) 2021 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <https://www.gnu.org/licenses/>.  */
+
+/* Produced by this program:
+
+   #include <stdio.h>
+   #include <unistd.h>
+   #include <setjmp.h>
+   #include <stddef.h>
+
+   int main (int argc, char **argv)
+   {
+       printf ("#define JMP_BUF_SIZE %d\n", sizeof (jmp_buf));
+       printf ("#define JMP_BUF_ALIGN %d\n", __alignof__ (jmp_buf));
+       printf ("#define SIGJMP_BUF_SIZE %d\n", sizeof (sigjmp_buf));
+       printf ("#define SIGJMP_BUF_ALIGN %d\n", __alignof__ (sigjmp_buf));
+       printf ("#define MASK_WAS_SAVED_OFFSET %d\n",
+	       offsetof (struct __jmp_buf_tag, __mask_was_saved));
+       printf ("#define SAVED_MASK_OFFSET %d\n",
+	       offsetof (struct __jmp_buf_tag, __saved_mask));
+   } */
+
+#define JMP_BUF_SIZE 304
+#define JMP_BUF_ALIGN 8
+#define SIGJMP_BUF_SIZE 304
+#define SIGJMP_BUF_ALIGN 8
+#define MASK_WAS_SAVED_OFFSET 168
+#define SAVED_MASK_OFFSET 176
-- 
2.34.0

